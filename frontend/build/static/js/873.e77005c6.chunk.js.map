{"version":3,"file":"static/js/873.e77005c6.chunk.js","mappings":"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","sources":["../node_modules/@web3auth/phantom-adapter/node_modules/@web3auth/base/src/chain/IChainInterface.ts","../node_modules/@web3auth/phantom-adapter/node_modules/@web3auth/base/src/errors/index.ts","../node_modules/@web3auth/phantom-adapter/node_modules/@web3auth/base/src/wallet/index.ts","../node_modules/@web3auth/phantom-adapter/node_modules/@web3auth/base/src/adapter/IAdapter.ts","../node_modules/@web3auth/phantom-adapter/node_modules/@web3auth/base/src/loglevel.ts","../node_modules/@web3auth/phantom-adapter/src/utils.ts","../node_modules/@web3auth/phantom-adapter/src/phantomAdapter.ts"],"sourcesContent":["export const CHAIN_NAMESPACES = {\n  EIP155: \"eip155\",\n  SOLANA: \"solana\",\n  OTHER: \"other\",\n} as const;\n// eip155 for all evm chains\nexport type ChainNamespaceType = (typeof CHAIN_NAMESPACES)[keyof typeof CHAIN_NAMESPACES];\n\nexport const ADAPTER_NAMESPACES = {\n  EIP155: \"eip155\",\n  SOLANA: \"solana\",\n  MULTICHAIN: \"multichain\",\n} as const;\n// eip155 for all evm chains\nexport type AdapterNamespaceType = (typeof ADAPTER_NAMESPACES)[keyof typeof ADAPTER_NAMESPACES];\n\nexport type CustomChainConfig = {\n  chainNamespace: ChainNamespaceType;\n  /**\n   * The chain id of the chain\n   */\n  chainId: string;\n  /**\n   * RPC target Url for the chain\n   */\n  rpcTarget: string;\n  /**\n   * Display Name for the chain\n   */\n  displayName: string;\n  /**\n   * Url of the block explorer\n   */\n  blockExplorer: string;\n  /**\n   * Default currency ticker of the network (e.g: ETH)\n   */\n  ticker: string;\n  /**\n   * Name for currency ticker (e.g: `Ethereum`)\n   */\n  tickerName: string;\n  /**\n   * Number of decimals for the currency ticker (e.g: 18)\n   */\n  decimals?: number;\n};\n","import { CustomError } from \"ts-custom-error\";\n\n// @flow\nexport interface IWeb3AuthError extends CustomError {\n  code: number;\n  message: string;\n  toString(): string;\n}\n\nexport type ErrorCodes = {\n  [key: number]: string;\n};\n\nexport abstract class Web3AuthError extends CustomError implements IWeb3AuthError {\n  code: number;\n\n  message: string;\n\n  public constructor(code: number, message?: string) {\n    // takes care of stack and proto\n    super(message);\n\n    this.code = code;\n    this.message = message || \"\";\n    // Set name explicitly as minification can mangle class names\n    Object.defineProperty(this, \"name\", { value: \"Web3AuthError\" });\n  }\n\n  toJSON(): IWeb3AuthError {\n    return {\n      name: this.name,\n      code: this.code,\n      message: this.message,\n    };\n  }\n\n  toString(): string {\n    return JSON.stringify(this.toJSON());\n  }\n}\n\nexport class WalletInitializationError extends Web3AuthError {\n  protected static messages: ErrorCodes = {\n    5000: \"Custom\",\n    5001: \"Wallet is not found\",\n    5002: \"Wallet is not installed\",\n    5003: \"Wallet is not ready yet\",\n    5004: \"Wallet window is blocked\",\n    5005: \"Wallet window has been closed by the user\",\n    5006: \"Incompatible chain namespace provided\",\n    5007: \"Adapter has already been included\",\n    5008: \"Invalid provider Config\",\n    5009: \"Provider is not ready yet\",\n    5010: \"Failed to connect with rpc url\",\n    5011: \"Invalid params passed in\",\n    5013: \"Invalid network provided\",\n  };\n\n  public constructor(code: number, message?: string) {\n    // takes care of stack and proto\n    super(code, message);\n\n    // Set name explicitly as minification can mangle class names\n    Object.defineProperty(this, \"name\", { value: \"WalletInitializationError\" });\n  }\n\n  public static fromCode(code: number, extraMessage = \"\"): IWeb3AuthError {\n    return new WalletInitializationError(code, `${WalletInitializationError.messages[code]}, ${extraMessage}`);\n  }\n\n  // Custom methods\n  public static notFound(extraMessage = \"\"): IWeb3AuthError {\n    return WalletInitializationError.fromCode(5001, extraMessage);\n  }\n\n  public static notInstalled(extraMessage = \"\"): IWeb3AuthError {\n    return WalletInitializationError.fromCode(5002, extraMessage);\n  }\n\n  public static notReady(extraMessage = \"\"): IWeb3AuthError {\n    return WalletInitializationError.fromCode(5003, extraMessage);\n  }\n\n  public static windowBlocked(extraMessage = \"\"): IWeb3AuthError {\n    return WalletInitializationError.fromCode(5004, extraMessage);\n  }\n\n  public static windowClosed(extraMessage = \"\"): IWeb3AuthError {\n    return WalletInitializationError.fromCode(5005, extraMessage);\n  }\n\n  public static incompatibleChainNameSpace(extraMessage = \"\"): IWeb3AuthError {\n    return WalletInitializationError.fromCode(5006, extraMessage);\n  }\n\n  public static duplicateAdapterError(extraMessage = \"\"): IWeb3AuthError {\n    return WalletInitializationError.fromCode(5007, extraMessage);\n  }\n\n  public static invalidProviderConfigError(extraMessage = \"\"): IWeb3AuthError {\n    return WalletInitializationError.fromCode(5008, extraMessage);\n  }\n\n  public static providerNotReadyError(extraMessage = \"\"): IWeb3AuthError {\n    return WalletInitializationError.fromCode(5009, extraMessage);\n  }\n\n  public static rpcConnectionError(extraMessage = \"\"): IWeb3AuthError {\n    return WalletInitializationError.fromCode(5010, extraMessage);\n  }\n\n  public static invalidParams(extraMessage = \"\"): IWeb3AuthError {\n    return WalletInitializationError.fromCode(5011, extraMessage);\n  }\n\n  public static invalidNetwork(extraMessage = \"\"): IWeb3AuthError {\n    return WalletInitializationError.fromCode(5013, extraMessage);\n  }\n}\n\n/**\n * wallet login errors\n */\n\nexport class WalletLoginError extends Web3AuthError {\n  protected static messages: ErrorCodes = {\n    5000: \"Custom\",\n    5111: \"Failed to connect with wallet\",\n    5112: \"Failed to disconnect from wallet\",\n    5113: \"Wallet is not connected\",\n    5114: \"Wallet popup has been closed by the user\",\n    5115: \"User has already enabled mfa, please use the @web3auth/web3auth-web sdk for login with mfa\",\n  };\n\n  public constructor(code: number, message?: string) {\n    // takes care of stack and proto\n    super(code, message);\n\n    // Set name explicitly as minification can mangle class names\n    Object.defineProperty(this, \"name\", { value: \"WalletLoginError\" });\n  }\n\n  public static fromCode(code: number, extraMessage = \"\"): IWeb3AuthError {\n    return new WalletLoginError(code, `${WalletLoginError.messages[code]}. ${extraMessage}`);\n  }\n\n  public static connectionError(extraMessage = \"\"): IWeb3AuthError {\n    return WalletLoginError.fromCode(5111, extraMessage);\n  }\n\n  public static disconnectionError(extraMessage = \"\"): IWeb3AuthError {\n    return WalletLoginError.fromCode(5112, extraMessage);\n  }\n\n  public static notConnectedError(extraMessage = \"\"): IWeb3AuthError {\n    return WalletLoginError.fromCode(5113, extraMessage);\n  }\n\n  public static popupClosed(extraMessage = \"\"): IWeb3AuthError {\n    return WalletLoginError.fromCode(5114, extraMessage);\n  }\n\n  public static mfaEnabled(extraMessage = \"\"): IWeb3AuthError {\n    return WalletLoginError.fromCode(5115, extraMessage);\n  }\n}\n","export const MULTI_CHAIN_ADAPTERS = {\n  OPENLOGIN: \"openlogin\",\n  WALLET_CONNECT_V1: \"wallet-connect-v1\",\n  WALLET_CONNECT_V2: \"wallet-connect-v2\",\n};\n\nexport const SOLANA_ADAPTERS = {\n  TORUS_SOLANA: \"torus-solana\",\n  PHANTOM: \"phantom\",\n  SOLFLARE: \"solflare\",\n  SLOPE: \"slope\",\n  ...MULTI_CHAIN_ADAPTERS,\n};\n\nexport const EVM_ADAPTERS = {\n  TORUS_EVM: \"torus-evm\",\n  METAMASK: \"metamask\",\n  COINBASE: \"coinbase\",\n  ...MULTI_CHAIN_ADAPTERS,\n};\n\nexport const WALLET_ADAPTERS = {\n  ...EVM_ADAPTERS,\n  ...SOLANA_ADAPTERS,\n};\nexport type WALLET_ADAPTER_TYPE = (typeof WALLET_ADAPTERS)[keyof typeof WALLET_ADAPTERS];\nexport type SOLANA_ADAPTER_TYPE = (typeof SOLANA_ADAPTERS)[keyof typeof SOLANA_ADAPTERS];\nexport type EVM_ADAPTER_TYPE = (typeof EVM_ADAPTERS)[keyof typeof EVM_ADAPTERS];\nexport type MULTI_CHAIN_ADAPTER_TYPE = (typeof MULTI_CHAIN_ADAPTERS)[keyof typeof MULTI_CHAIN_ADAPTERS];\n\nexport const ADAPTER_NAMES = {\n  [MULTI_CHAIN_ADAPTERS.OPENLOGIN]: \"OpenLogin\",\n  [MULTI_CHAIN_ADAPTERS.WALLET_CONNECT_V1]: \"Wallet Connect v1\",\n  [MULTI_CHAIN_ADAPTERS.WALLET_CONNECT_V2]: \"Wallet Connect v2\",\n  [SOLANA_ADAPTERS.TORUS_SOLANA]: \"Torus\",\n  [SOLANA_ADAPTERS.PHANTOM]: \"Phantom\",\n  [SOLANA_ADAPTERS.SOLFLARE]: \"Solflare\",\n  [SOLANA_ADAPTERS.SLOPE]: \"Slope\",\n  [EVM_ADAPTERS.TORUS_EVM]: \"Torus\",\n  [EVM_ADAPTERS.METAMASK]: \"Metamask\",\n  [EVM_ADAPTERS.COINBASE]: \"Coinbase\",\n};\n","import { OPENLOGIN_NETWORK, OPENLOGIN_NETWORK_TYPE, OpenloginUserInfo } from \"@toruslabs/openlogin\";\nimport { SafeEventEmitter } from \"@toruslabs/openlogin-jrpc\";\n\nimport { getChainConfig } from \"../chain/config\";\nimport { AdapterNamespaceType, CHAIN_NAMESPACES, ChainNamespaceType, CustomChainConfig } from \"../chain/IChainInterface\";\nimport { WalletInitializationError, WalletLoginError } from \"../errors\";\nimport { SafeEventEmitterProvider } from \"../provider/IProvider\";\nimport { WALLET_ADAPTERS } from \"../wallet\";\n\nexport type UserInfo = OpenloginUserInfo;\n\nexport const ADAPTER_CATEGORY = {\n  EXTERNAL: \"external\",\n  IN_APP: \"in_app\",\n} as const;\nexport type ADAPTER_CATEGORY_TYPE = (typeof ADAPTER_CATEGORY)[keyof typeof ADAPTER_CATEGORY];\n\nexport interface AdapterInitOptions {\n  /**\n   * Whether to auto connect to the adapter based on redirect mode or saved adapters\n   */\n  autoConnect?: boolean;\n}\n\nexport const ADAPTER_STATUS = {\n  NOT_READY: \"not_ready\",\n  READY: \"ready\",\n  CONNECTING: \"connecting\",\n  CONNECTED: \"connected\",\n  DISCONNECTED: \"disconnected\",\n  ERRORED: \"errored\",\n} as const;\n\nexport const ADAPTER_EVENTS = {\n  ...ADAPTER_STATUS,\n  ADAPTER_DATA_UPDATED: \"adapter_data_updated\",\n} as const;\nexport type ADAPTER_STATUS_TYPE = (typeof ADAPTER_STATUS)[keyof typeof ADAPTER_STATUS];\n\nexport type CONNECTED_EVENT_DATA = {\n  adapter: string;\n  reconnected: boolean;\n};\n\nexport type UserAuthInfo = { idToken: string };\n\nexport interface BaseAdapterSettings {\n  clientId?: string;\n  sessionTime?: number;\n  chainConfig?: Partial<CustomChainConfig> & Pick<CustomChainConfig, \"chainNamespace\">;\n  web3AuthNetwork?: OPENLOGIN_NETWORK_TYPE;\n  useCoreKitKey?: boolean;\n}\n\nexport interface IAdapter<T> extends SafeEventEmitter {\n  adapterNamespace: AdapterNamespaceType;\n  currentChainNamespace: ChainNamespaceType;\n  chainConfigProxy: CustomChainConfig | null;\n  type: ADAPTER_CATEGORY_TYPE;\n  name: string;\n  sessionTime: number;\n  web3AuthNetwork: OPENLOGIN_NETWORK_TYPE;\n  clientId: string;\n  status: ADAPTER_STATUS_TYPE;\n  provider: SafeEventEmitterProvider | null;\n  adapterData?: unknown;\n  init(options?: AdapterInitOptions): Promise<void>;\n  disconnect(options?: { cleanup: boolean }): Promise<void>;\n  connect(params?: T): Promise<SafeEventEmitterProvider | null>;\n  getUserInfo(): Promise<Partial<UserInfo>>;\n  setAdapterSettings(adapterSettings: BaseAdapterSettings): void;\n  authenticateUser(): Promise<UserAuthInfo>;\n}\n\nexport abstract class BaseAdapter<T> extends SafeEventEmitter implements IAdapter<T> {\n  public adapterData?: unknown = {};\n\n  public sessionTime = 86400;\n\n  public clientId: string;\n\n  public web3AuthNetwork: OPENLOGIN_NETWORK_TYPE = OPENLOGIN_NETWORK.MAINNET;\n\n  protected rehydrated = false;\n\n  // should be added in constructor or from setAdapterSettings function\n  // before calling init function.\n  protected chainConfig: CustomChainConfig | null = null;\n\n  public abstract adapterNamespace: AdapterNamespaceType;\n\n  public abstract currentChainNamespace: ChainNamespaceType;\n\n  public abstract type: ADAPTER_CATEGORY_TYPE;\n\n  public abstract name: string;\n\n  public abstract status: ADAPTER_STATUS_TYPE;\n\n  constructor(options: BaseAdapterSettings = {}) {\n    super();\n    this.setAdapterSettings(options);\n  }\n\n  get chainConfigProxy(): CustomChainConfig | null {\n    return this.chainConfig ? { ...this.chainConfig } : null;\n  }\n\n  public abstract get provider(): SafeEventEmitterProvider | null;\n\n  public setAdapterSettings(options: BaseAdapterSettings): void {\n    if (this.status === ADAPTER_STATUS.READY) return;\n    if (options?.sessionTime) {\n      this.sessionTime = options.sessionTime;\n    }\n    if (options?.clientId) {\n      this.clientId = options.clientId;\n    }\n    if (options?.web3AuthNetwork) {\n      this.web3AuthNetwork = options.web3AuthNetwork;\n    }\n    const customChainConfig = options.chainConfig;\n    if (customChainConfig) {\n      if (!customChainConfig.chainNamespace) throw WalletInitializationError.notReady(\"ChainNamespace is required while setting chainConfig\");\n      this.currentChainNamespace = customChainConfig.chainNamespace;\n      // chainId is optional in this function.\n      // we go with mainnet chainId by default.\n      const defaultChainConfig = getChainConfig(customChainConfig.chainNamespace, customChainConfig.chainId);\n      // NOTE: It is being forced casted to CustomChainConfig to handle OTHER Chainnamespace\n      // where chainConfig is not required.\n      const finalChainConfig = { ...(defaultChainConfig || {}), ...customChainConfig } as CustomChainConfig;\n\n      this.chainConfig = finalChainConfig;\n    }\n  }\n\n  checkConnectionRequirements(): void {\n    // we reconnect without killing existing wallet connect session on calling connect again.\n    if (this.name === WALLET_ADAPTERS.WALLET_CONNECT_V1 && this.status === ADAPTER_STATUS.CONNECTING) return;\n    else if (this.status === ADAPTER_STATUS.CONNECTING) throw WalletInitializationError.notReady(\"Already connecting\");\n\n    if (this.status === ADAPTER_STATUS.CONNECTED) throw WalletLoginError.connectionError(\"Already connected\");\n    if (this.status !== ADAPTER_STATUS.READY)\n      throw WalletLoginError.connectionError(\n        \"Wallet adapter is not ready yet, Please wait for init function to resolve before calling connect/connectTo function\"\n      );\n  }\n\n  checkInitializationRequirements(): void {\n    if (!this.clientId) throw WalletInitializationError.invalidParams(\"Please initialize Web3Auth with a valid clientId in constructor\");\n    if (!this.chainConfig) throw WalletInitializationError.invalidParams(\"rpcTarget is required in chainConfig\");\n    if (!this.chainConfig.rpcTarget && this.chainConfig.chainNamespace !== CHAIN_NAMESPACES.OTHER) {\n      throw WalletInitializationError.invalidParams(\"rpcTarget is required in chainConfig\");\n    }\n\n    if (!this.chainConfig.chainId && this.chainConfig.chainNamespace !== CHAIN_NAMESPACES.OTHER) {\n      throw WalletInitializationError.invalidParams(\"chainID is required in chainConfig\");\n    }\n    if (this.status === ADAPTER_STATUS.NOT_READY) return;\n    if (this.status === ADAPTER_STATUS.CONNECTED) throw WalletInitializationError.notReady(\"Already connected\");\n    if (this.status === ADAPTER_STATUS.READY) throw WalletInitializationError.notReady(\"Adapter is already initialized\");\n  }\n\n  checkDisconnectionRequirements(): void {\n    if (this.status !== ADAPTER_STATUS.CONNECTED) throw WalletLoginError.disconnectionError(\"Not connected with wallet\");\n  }\n\n  updateAdapterData(data: unknown): void {\n    this.adapterData = data;\n    this.emit(ADAPTER_EVENTS.ADAPTER_DATA_UPDATED, { adapterName: this.name, data });\n  }\n\n  abstract init(options?: AdapterInitOptions): Promise<void>;\n  abstract connect(params?: T): Promise<SafeEventEmitterProvider | null>;\n  abstract disconnect(): Promise<void>;\n  abstract getUserInfo(): Promise<Partial<UserInfo>>;\n  abstract authenticateUser(): Promise<UserAuthInfo>;\n}\n\nexport interface BaseAdapterConfig {\n  label: string;\n  showOnModal?: boolean;\n  showOnMobile?: boolean;\n  showOnDesktop?: boolean;\n}\n\nexport type LoginMethodConfig = Record<\n  string,\n  {\n    /**\n     * Display Name. If not provided, we use the default for openlogin app\n     */\n    name: string;\n    /**\n     * Description for button. If provided, it renders as a full length button. else, icon button\n     */\n    description?: string;\n    /**\n     * Logo to be shown on mouse hover. If not provided, we use the default for openlogin app\n     */\n    logoHover?: string;\n    /**\n     * Logo to be shown on dark background (dark theme). If not provided, we use the default for openlogin app\n     */\n    logoLight?: string;\n    /**\n     * Logo to be shown on light background (light theme). If not provided, we use the default for openlogin app\n     */\n    logoDark?: string;\n    /**\n     * Show login button on the main list\n     */\n    mainOption?: boolean;\n    /**\n     * Whether to show the login button on modal or not\n     */\n    showOnModal?: boolean;\n    /**\n     * Whether to show the login button on desktop\n     */\n    showOnDesktop?: boolean;\n    /**\n     * Whether to show the login button on mobile\n     */\n    showOnMobile?: boolean;\n  }\n>;\n\nexport interface IWalletConnectExtensionAdapter {\n  name: string;\n  chains: ChainNamespaceType[];\n  logo: string;\n  mobile: {\n    native: string;\n    universal: string;\n  };\n  desktop: {\n    native: string;\n    universal: string;\n  };\n}\n\nexport interface WalletConnectV1Data {\n  uri: string;\n  extensionAdapters: IWalletConnectExtensionAdapter[];\n}\n\nexport interface IAdapterDataEvent {\n  adapterName: string;\n  data: unknown;\n}\n\nexport interface INetworkSwitchProvider {\n  addChain(chainConfig: CustomChainConfig): Promise<void>;\n  switchChain(chainId: string): Promise<void>;\n}\nexport interface INetworkSwitch {\n  addNetwork(params: { chainConfig: CustomChainConfig; appOrigin: string }): Promise<boolean>;\n  switchNetwork(params: { currentChainConfig: CustomChainConfig; newChainConfig: Partial<CustomChainConfig>; appOrigin: string }): Promise<boolean>;\n}\n\nexport abstract class BaseNetworkSwitch implements INetworkSwitch {\n  abstract switchNetwork(params: {\n    currentChainConfig: CustomChainConfig;\n    newChainConfig: Partial<CustomChainConfig>;\n    appOrigin: string;\n  }): Promise<boolean>;\n\n  abstract addNetwork(params: { chainConfig: CustomChainConfig; appOrigin: string }): Promise<boolean>;\n}\n","import loglevel from \"loglevel\";\n\nexport default loglevel.getLogger(\"web3auth-logger\");\n","import type { IPhantomWalletProvider } from \"@web3auth/solana-provider\";\n\nexport function poll(callback: () => boolean | Promise<boolean>, interval: number, count: number): Promise<boolean> {\n  return new Promise((resolve, reject) => {\n    if (count > 0) {\n      setTimeout(async () => {\n        const done = await callback();\n        if (done) resolve(done);\n        if (!done)\n          poll(callback, interval, count - 1)\n            .then((res) => {\n              resolve(res);\n              return res;\n            })\n            .catch((err) => reject(err));\n      }, interval);\n    } else {\n      resolve(false);\n    }\n  });\n}\n\nexport const detectProvider = async (\n  options: { interval: number; count: number } = { interval: 1000, count: 3 }\n): Promise<IPhantomWalletProvider | null> => {\n  const isPhantomAvailable = typeof window !== \"undefined\" && !!(window as any).solana?.isPhantom;\n  if (isPhantomAvailable) {\n    return (window as any).solana;\n  }\n  const isAvailable = await poll(() => (window as any).solana?.isPhantom, options.interval, options.count);\n  if (isAvailable) return (window as any).solana;\n  return null;\n};\n","import {\n  ADAPTER_CATEGORY,\n  ADAPTER_CATEGORY_TYPE,\n  ADAPTER_EVENTS,\n  ADAPTER_NAMESPACES,\n  ADAPTER_STATUS,\n  ADAPTER_STATUS_TYPE,\n  AdapterInitOptions,\n  AdapterNamespaceType,\n  BaseAdapterSettings,\n  CHAIN_NAMESPACES,\n  ChainNamespaceType,\n  CONNECTED_EVENT_DATA,\n  CustomChainConfig,\n  log,\n  SafeEventEmitterProvider,\n  UserInfo,\n  WALLET_ADAPTERS,\n  WalletInitializationError,\n  WalletLoginError,\n  Web3AuthError,\n} from \"@web3auth/base\";\nimport { BaseSolanaAdapter } from \"@web3auth/base-solana-adapter\";\nimport { IPhantomWalletProvider, PhantomInjectedProvider } from \"@web3auth/solana-provider\";\n\nimport { detectProvider } from \"./utils\";\nexport type PhantomAdapterOptions = BaseAdapterSettings;\n\nexport class PhantomAdapter extends BaseSolanaAdapter<void> {\n  readonly name: string = WALLET_ADAPTERS.PHANTOM;\n\n  readonly adapterNamespace: AdapterNamespaceType = ADAPTER_NAMESPACES.SOLANA;\n\n  readonly currentChainNamespace: ChainNamespaceType = CHAIN_NAMESPACES.SOLANA;\n\n  readonly type: ADAPTER_CATEGORY_TYPE = ADAPTER_CATEGORY.EXTERNAL;\n\n  public status: ADAPTER_STATUS_TYPE = ADAPTER_STATUS.NOT_READY;\n\n  public _wallet: IPhantomWalletProvider | null = null;\n\n  private phantomProvider: PhantomInjectedProvider | null = null;\n\n  get isWalletConnected(): boolean {\n    return !!(this._wallet?.isConnected && this.status === ADAPTER_STATUS.CONNECTED);\n  }\n\n  get provider(): SafeEventEmitterProvider | null {\n    return this.phantomProvider?.provider || null;\n  }\n\n  set provider(_: SafeEventEmitterProvider | null) {\n    throw new Error(\"Not implemented\");\n  }\n\n  async init(options: AdapterInitOptions = {}): Promise<void> {\n    await super.init(options);\n    super.checkInitializationRequirements();\n    this._wallet = await detectProvider({ interval: 500, count: 3 });\n    if (!this._wallet) throw WalletInitializationError.notInstalled();\n    this.phantomProvider = new PhantomInjectedProvider({ config: { chainConfig: this.chainConfig as CustomChainConfig } });\n    this.status = ADAPTER_STATUS.READY;\n    this.emit(ADAPTER_EVENTS.READY, WALLET_ADAPTERS.PHANTOM);\n\n    try {\n      log.debug(\"initializing phantom adapter\");\n      if (options.autoConnect) {\n        this.rehydrated = true;\n        await this.connect();\n      }\n    } catch (error) {\n      log.error(\"Failed to connect with cached phantom provider\", error);\n      this.emit(\"ERRORED\", error);\n    }\n  }\n\n  async connect(): Promise<SafeEventEmitterProvider | null> {\n    try {\n      super.checkConnectionRequirements();\n      this.status = ADAPTER_STATUS.CONNECTING;\n      this.emit(ADAPTER_EVENTS.CONNECTING, { adapter: WALLET_ADAPTERS.PHANTOM });\n\n      if (!this._wallet) throw WalletInitializationError.notInstalled();\n      if (!this._wallet.isConnected) {\n        const handleDisconnect = this._wallet._handleDisconnect;\n        try {\n          await new Promise<SafeEventEmitterProvider | null>((resolve, reject) => {\n            const connect = async () => {\n              await this.connectWithProvider(this._wallet as IPhantomWalletProvider);\n              resolve(this.provider);\n            };\n            if (!this._wallet) {\n              reject(WalletInitializationError.notInstalled());\n              return;\n            }\n            this._wallet.once(\"connect\", connect);\n            // Raise an issue on phantom that if window is closed, disconnect event is not fired\n            (this._wallet as IPhantomWalletProvider)._handleDisconnect = (...args: unknown[]) => {\n              reject(WalletInitializationError.windowClosed());\n              return handleDisconnect.apply(this._wallet, args);\n            };\n\n            this._wallet.connect().catch((reason: unknown) => {\n              reject(reason);\n            });\n          });\n        } catch (error: unknown) {\n          if (error instanceof Web3AuthError) throw error;\n          throw WalletLoginError.connectionError((error as Error)?.message);\n        } finally {\n          this._wallet._handleDisconnect = handleDisconnect;\n        }\n      } else {\n        await this.connectWithProvider(this._wallet);\n      }\n\n      if (!this._wallet.publicKey) throw WalletLoginError.connectionError();\n      this._wallet.on(\"disconnect\", this._onDisconnect);\n\n      return this.provider;\n    } catch (error: unknown) {\n      // ready again to be connected\n      this.status = ADAPTER_STATUS.READY;\n      this.rehydrated = false;\n      this.emit(ADAPTER_EVENTS.ERRORED, error);\n      throw error;\n    }\n  }\n\n  async disconnect(options: { cleanup: boolean } = { cleanup: false }): Promise<void> {\n    await super.disconnectSession();\n    try {\n      await this._wallet?.disconnect();\n      if (options.cleanup) {\n        this.status = ADAPTER_STATUS.NOT_READY;\n        this.phantomProvider = null;\n        this._wallet = null;\n      }\n      await super.disconnect();\n    } catch (error: unknown) {\n      this.emit(ADAPTER_EVENTS.ERRORED, WalletLoginError.disconnectionError((error as Error)?.message));\n    }\n  }\n\n  async getUserInfo(): Promise<Partial<UserInfo>> {\n    if (!this.isWalletConnected) throw WalletLoginError.notConnectedError(\"Not connected with wallet, Please login/connect first\");\n    return {};\n  }\n\n  private async connectWithProvider(injectedProvider: IPhantomWalletProvider): Promise<SafeEventEmitterProvider | null> {\n    if (!this.phantomProvider) throw WalletLoginError.connectionError(\"No phantom provider\");\n    await this.phantomProvider.setupProvider(injectedProvider);\n    this.status = ADAPTER_STATUS.CONNECTED;\n    this.emit(ADAPTER_EVENTS.CONNECTED, { adapter: WALLET_ADAPTERS.PHANTOM, reconnected: this.rehydrated } as CONNECTED_EVENT_DATA);\n    return this.provider;\n  }\n\n  private _onDisconnect = () => {\n    if (this._wallet) {\n      this._wallet.off(\"disconnect\", this._onDisconnect);\n      this.rehydrated = false;\n      // ready to be connected again only if it was previously connected and not cleaned up\n      this.status = this.status === ADAPTER_STATUS.CONNECTED ? ADAPTER_STATUS.READY : ADAPTER_STATUS.NOT_READY;\n      this.emit(ADAPTER_EVENTS.DISCONNECTED);\n    }\n  };\n}\n"],"names":["CHAIN_NAMESPACES","ADAPTER_NAMESPACES","Web3AuthError","CustomError","constructor","code","message","super","_defineProperty","this","Object","defineProperty","value","toJSON","name","toString","JSON","stringify","WalletInitializationError","fromCode","extraMessage","arguments","length","undefined","concat","messages","notFound","notInstalled","notReady","windowBlocked","windowClosed","incompatibleChainNameSpace","duplicateAdapterError","invalidProviderConfigError","providerNotReadyError","rpcConnectionError","invalidParams","invalidNetwork","WalletLoginError","connectionError","disconnectionError","notConnectedError","popupClosed","mfaEnabled","MULTI_CHAIN_ADAPTERS","OPENLOGIN","WALLET_CONNECT_V1","WALLET_CONNECT_V2","SOLANA_ADAPTERS","_objectSpread$1","TORUS_SOLANA","PHANTOM","SOLFLARE","SLOPE","EVM_ADAPTERS","TORUS_EVM","METAMASK","COINBASE","WALLET_ADAPTERS","ADAPTER_CATEGORY","ADAPTER_STATUS","NOT_READY","READY","CONNECTING","CONNECTED","DISCONNECTED","ERRORED","ADAPTER_EVENTS","_objectSpread","ADAPTER_DATA_UPDATED","log","loglevel","poll","callback","interval","count","Promise","resolve","reject","setTimeout","async","done","then","res","catch","err","detectProvider","_window$solana","options","window","solana","isPhantom","_window$solana2","PhantomAdapter","BaseSolanaAdapter","_wallet","off","_onDisconnect","rehydrated","status","emit","isWalletConnected","_this$_wallet","isConnected","provider","_this$phantomProvider","phantomProvider","_","Error","init","checkInitializationRequirements","PhantomInjectedProvider","config","chainConfig","debug","autoConnect","connect","error","_this","checkConnectionRequirements","adapter","connectWithProvider","handleDisconnect","_handleDisconnect","once","_len","args","Array","_key","apply","reason","publicKey","on","disconnect","cleanup","disconnectSession","_this$_wallet2","getUserInfo","injectedProvider","setupProvider","reconnected"],"sourceRoot":""}