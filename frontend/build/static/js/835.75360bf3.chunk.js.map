{"version":3,"file":"static/js/835.75360bf3.chunk.js","mappings":"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","sources":["../node_modules/@safe-global/auth-kit/node_modules/@web3auth/openlogin-adapter/src/config.ts","../node_modules/@safe-global/auth-kit/node_modules/@web3auth/openlogin-adapter/src/openloginAdapter.ts"],"sourcesContent":["import { OPENLOGIN_NETWORK, UX_MODE } from \"@toruslabs/openlogin\";\n\nimport { OpenloginAdapterOptions } from \"./interface\";\n\nexport const getOpenloginDefaultOptions = (): OpenloginAdapterOptions => {\n  return {\n    adapterSettings: {\n      network: OPENLOGIN_NETWORK.MAINNET,\n      clientId: \"\",\n      uxMode: UX_MODE.POPUP,\n    },\n    loginSettings: {},\n  };\n};\n","import OpenLogin, { getHashQueryParams, LoginParams, OPENLOGIN_NETWORK, OpenLoginOptions, SUPPORTED_KEY_CURVES, UX_MODE } from \"@toruslabs/openlogin\";\nimport {\n  ADAPTER_CATEGORY,\n  ADAPTER_CATEGORY_TYPE,\n  ADAPTER_EVENTS,\n  ADAPTER_NAMESPACES,\n  ADAPTER_STATUS,\n  ADAPTER_STATUS_TYPE,\n  AdapterInitOptions,\n  AdapterNamespaceType,\n  BaseAdapter,\n  BaseAdapterSettings,\n  CHAIN_NAMESPACES,\n  ChainNamespaceType,\n  CONNECTED_EVENT_DATA,\n  CustomChainConfig,\n  log,\n  SafeEventEmitterProvider,\n  UserInfo,\n  WALLET_ADAPTERS,\n  WalletInitializationError,\n  WalletLoginError,\n} from \"@web3auth/base\";\nimport { CommonPrivateKeyProvider, IBaseProvider } from \"@web3auth/base-provider\";\nimport merge from \"lodash.merge\";\n\nimport { getOpenloginDefaultOptions } from \"./config\";\nimport type { LoginSettings, OpenloginAdapterOptions } from \"./interface\";\n\nexport type OpenloginLoginParams = LoginParams & {\n  // to maintain backward compatibility\n  login_hint?: string;\n};\n\ntype PrivateKeyProvider = IBaseProvider<string>;\n\nexport class OpenloginAdapter extends BaseAdapter<OpenloginLoginParams> {\n  readonly name: string = WALLET_ADAPTERS.OPENLOGIN;\n\n  readonly adapterNamespace: AdapterNamespaceType = ADAPTER_NAMESPACES.MULTICHAIN;\n\n  readonly type: ADAPTER_CATEGORY_TYPE = ADAPTER_CATEGORY.IN_APP;\n\n  public openloginInstance: OpenLogin | null = null;\n\n  public status: ADAPTER_STATUS_TYPE = ADAPTER_STATUS.NOT_READY;\n\n  public currentChainNamespace: ChainNamespaceType = CHAIN_NAMESPACES.EIP155;\n\n  private openloginOptions: OpenloginAdapterOptions[\"adapterSettings\"];\n\n  private loginSettings: LoginSettings = { loginProvider: \"\" };\n\n  private privKeyProvider: PrivateKeyProvider | null = null;\n\n  constructor(params: OpenloginAdapterOptions = {}) {\n    super(params);\n    this.setAdapterSettings({\n      ...params.adapterSettings,\n      chainConfig: params.chainConfig,\n      clientId: params.clientId || \"\",\n      sessionTime: params.sessionTime,\n      web3AuthNetwork: params.web3AuthNetwork,\n      useCoreKitKey: params.useCoreKitKey,\n    });\n    this.loginSettings = params.loginSettings || { loginProvider: \"\" };\n  }\n\n  get chainConfigProxy(): CustomChainConfig | null {\n    return this.chainConfig ? { ...this.chainConfig } : null;\n  }\n\n  get provider(): SafeEventEmitterProvider | null {\n    return this.privKeyProvider?.provider || null;\n  }\n\n  set provider(_: SafeEventEmitterProvider | null) {\n    throw new Error(\"Not implemented\");\n  }\n\n  async init(options: AdapterInitOptions): Promise<void> {\n    super.checkInitializationRequirements();\n    if (!this.clientId) throw WalletInitializationError.invalidParams(\"clientId is required before openlogin's initialization\");\n    if (!this.openloginOptions) throw WalletInitializationError.invalidParams(\"openloginOptions is required before openlogin's initialization\");\n    let isRedirectResult = false;\n\n    if (this.openloginOptions.uxMode === UX_MODE.REDIRECT || this.openloginOptions.uxMode === UX_MODE.SESSIONLESS_REDIRECT) {\n      const redirectResult = getHashQueryParams();\n      if (Object.keys(redirectResult).length > 0 && redirectResult._pid) {\n        isRedirectResult = true;\n      }\n    }\n    this.openloginOptions = {\n      ...this.openloginOptions,\n      replaceUrlOnRedirect: isRedirectResult,\n    };\n    this.openloginInstance = new OpenLogin({\n      ...this.openloginOptions,\n      clientId: this.clientId,\n      network: this.openloginOptions.network || this.web3AuthNetwork || OPENLOGIN_NETWORK.MAINNET,\n    });\n    log.debug(\"initializing openlogin adapter init\");\n\n    await this.openloginInstance.init();\n\n    this.status = ADAPTER_STATUS.READY;\n    this.emit(ADAPTER_EVENTS.READY, WALLET_ADAPTERS.OPENLOGIN);\n\n    try {\n      log.debug(\"initializing openlogin adapter\");\n\n      const finalPrivKey = this._getFinalPrivKey();\n      // connect only if it is redirect result or if connect (adapter is cached/already connected in same session) is true\n      if (finalPrivKey && (options.autoConnect || isRedirectResult)) {\n        this.rehydrated = true;\n        await this.connect();\n      }\n    } catch (error) {\n      log.error(\"Failed to connect with cached openlogin provider\", error);\n      this.emit(\"ERRORED\", error);\n    }\n  }\n\n  async connect(params: OpenloginLoginParams = { loginProvider: \"\" }): Promise<SafeEventEmitterProvider | null> {\n    super.checkConnectionRequirements();\n    this.status = ADAPTER_STATUS.CONNECTING;\n    this.emit(ADAPTER_EVENTS.CONNECTING, { ...params, adapter: WALLET_ADAPTERS.OPENLOGIN });\n    try {\n      await this.connectWithProvider(params);\n      return this.provider;\n    } catch (error: unknown) {\n      log.error(\"Failed to connect with openlogin provider\", error);\n      // ready again to be connected\n      this.status = ADAPTER_STATUS.READY;\n      this.emit(ADAPTER_EVENTS.ERRORED, error);\n      if ((error as Error)?.message.includes(\"user closed popup\")) {\n        throw WalletLoginError.popupClosed();\n      }\n      throw WalletLoginError.connectionError(\"Failed to login with openlogin\");\n    }\n  }\n\n  async disconnect(options: { cleanup: boolean } = { cleanup: false }): Promise<void> {\n    if (this.status !== ADAPTER_STATUS.CONNECTED) throw WalletLoginError.notConnectedError(\"Not connected with wallet\");\n    if (!this.openloginInstance) throw WalletInitializationError.notReady(\"openloginInstance is not ready\");\n    await this.openloginInstance.logout();\n    if (options.cleanup) {\n      this.status = ADAPTER_STATUS.NOT_READY;\n      this.openloginInstance = null;\n      this.privKeyProvider = null;\n    } else {\n      // ready to be connected again\n      this.status = ADAPTER_STATUS.READY;\n    }\n\n    this.rehydrated = false;\n    this.emit(ADAPTER_EVENTS.DISCONNECTED);\n  }\n\n  async authenticateUser(): Promise<{ idToken: string }> {\n    if (this.status !== ADAPTER_STATUS.CONNECTED) throw WalletLoginError.notConnectedError(\"Not connected with wallet, Please login/connect first\");\n    const userInfo = await this.getUserInfo();\n    return {\n      idToken: userInfo.idToken as string,\n    };\n  }\n\n  async getUserInfo(): Promise<Partial<UserInfo>> {\n    if (this.status !== ADAPTER_STATUS.CONNECTED) throw WalletLoginError.notConnectedError(\"Not connected with wallet\");\n    if (!this.openloginInstance) throw WalletInitializationError.notReady(\"openloginInstance is not ready\");\n    const userInfo = await this.openloginInstance.getUserInfo();\n    return userInfo;\n  }\n\n  // should be called only before initialization.\n  setAdapterSettings(adapterSettings: Partial<OpenLoginOptions & BaseAdapterSettings>): void {\n    super.setAdapterSettings(adapterSettings);\n    const defaultOptions = getOpenloginDefaultOptions();\n    log.info(\"setting adapter settings\", adapterSettings);\n    this.openloginOptions = {\n      ...defaultOptions.adapterSettings,\n      ...this.openloginOptions,\n      ...adapterSettings,\n    };\n    if (adapterSettings.web3AuthNetwork) {\n      this.openloginOptions.network = adapterSettings.web3AuthNetwork;\n    }\n    if (adapterSettings.useCoreKitKey !== undefined) {\n      this.openloginOptions.useCoreKitKey = adapterSettings.useCoreKitKey;\n    }\n  }\n\n  private _getFinalPrivKey() {\n    if (!this.openloginInstance) return \"\";\n    let finalPrivKey = this.openloginInstance.privKey;\n    // coreKitKey is available only for custom verifiers by default\n    if (this.openloginOptions?.useCoreKitKey && this.openloginInstance.coreKitKey) {\n      finalPrivKey = this.openloginInstance.coreKitKey;\n    }\n    return finalPrivKey;\n  }\n\n  private async connectWithProvider(params: OpenloginLoginParams = { loginProvider: \"\" }): Promise<void> {\n    if (!this.chainConfig) throw WalletInitializationError.invalidParams(\"chainConfig is required before initialization\");\n    if (!this.openloginInstance) throw WalletInitializationError.notReady(\"openloginInstance is not ready\");\n\n    if (this.currentChainNamespace === CHAIN_NAMESPACES.SOLANA) {\n      const { SolanaPrivateKeyProvider } = await import(\"@web3auth/solana-provider\");\n      this.privKeyProvider = new SolanaPrivateKeyProvider({ config: { chainConfig: this.chainConfig } });\n    } else if (this.currentChainNamespace === CHAIN_NAMESPACES.EIP155) {\n      const { EthereumPrivateKeyProvider } = await import(\"@web3auth/ethereum-provider\");\n      this.privKeyProvider = new EthereumPrivateKeyProvider({ config: { chainConfig: this.chainConfig } });\n    } else if (this.currentChainNamespace === CHAIN_NAMESPACES.OTHER) {\n      this.privKeyProvider = new CommonPrivateKeyProvider();\n    } else {\n      throw new Error(`Invalid chainNamespace: ${this.currentChainNamespace} found while connecting to wallet`);\n    }\n    const keyAvailable = this._getFinalPrivKey();\n    // if not logged in then login\n    if (!keyAvailable || params.extraLoginOptions?.id_token) {\n      if (!this.loginSettings.curve) {\n        this.loginSettings.curve =\n          this.currentChainNamespace === CHAIN_NAMESPACES.SOLANA ? SUPPORTED_KEY_CURVES.ED25519 : SUPPORTED_KEY_CURVES.SECP256K1;\n      }\n      if (!params.loginProvider && !this.loginSettings.loginProvider)\n        throw WalletInitializationError.invalidParams(\"loginProvider is required for login\");\n      await this.openloginInstance.login(\n        merge(this.loginSettings, params, {\n          extraLoginOptions: { ...(params.extraLoginOptions || {}), login_hint: params.login_hint || params.extraLoginOptions?.login_hint },\n        })\n      );\n    }\n    let finalPrivKey = this._getFinalPrivKey();\n    if (finalPrivKey) {\n      if (this.currentChainNamespace === CHAIN_NAMESPACES.SOLANA) {\n        const { getED25519Key } = await import(\"@toruslabs/openlogin-ed25519\");\n        finalPrivKey = getED25519Key(finalPrivKey).sk.toString(\"hex\");\n      }\n      await this.privKeyProvider.setupProvider(finalPrivKey);\n      this.status = ADAPTER_STATUS.CONNECTED;\n      this.emit(ADAPTER_EVENTS.CONNECTED, { adapter: WALLET_ADAPTERS.OPENLOGIN, reconnected: this.rehydrated } as CONNECTED_EVENT_DATA);\n    }\n  }\n}\n"],"names":["getOpenloginDefaultOptions","adapterSettings","network","OPENLOGIN_NETWORK","MAINNET","clientId","uxMode","UX_MODE","POPUP","loginSettings","OpenloginAdapter","BaseAdapter","constructor","params","arguments","length","undefined","super","_defineProperty","WALLET_ADAPTERS","OPENLOGIN","ADAPTER_NAMESPACES","MULTICHAIN","ADAPTER_CATEGORY","IN_APP","ADAPTER_STATUS","NOT_READY","CHAIN_NAMESPACES","EIP155","loginProvider","this","setAdapterSettings","_objectSpread","chainConfig","sessionTime","web3AuthNetwork","useCoreKitKey","chainConfigProxy","provider","_this$privKeyProvider","privKeyProvider","_","Error","init","options","checkInitializationRequirements","WalletInitializationError","invalidParams","openloginOptions","isRedirectResult","REDIRECT","SESSIONLESS_REDIRECT","redirectResult","getHashQueryParams","Object","keys","_pid","replaceUrlOnRedirect","openloginInstance","OpenLogin","log","debug","status","READY","emit","ADAPTER_EVENTS","_getFinalPrivKey","autoConnect","rehydrated","connect","error","checkConnectionRequirements","CONNECTING","adapter","connectWithProvider","ERRORED","message","includes","WalletLoginError","popupClosed","connectionError","disconnect","cleanup","CONNECTED","notConnectedError","notReady","logout","DISCONNECTED","authenticateUser","idToken","getUserInfo","defaultOptions","info","_this$openloginOption","finalPrivKey","privKey","coreKitKey","_params$extraLoginOpt","currentChainNamespace","SOLANA","SolanaPrivateKeyProvider","config","EthereumPrivateKeyProvider","OTHER","concat","CommonPrivateKeyProvider","extraLoginOptions","id_token","_params$extraLoginOpt2","curve","SUPPORTED_KEY_CURVES","ED25519","SECP256K1","login","merge","login_hint","getED25519Key","sk","toString","setupProvider","reconnected"],"sourceRoot":""}