"use strict";(self.webpackChunkethglobalistanbul=self.webpackChunkethglobalistanbul||[]).push([[835],{93835:(t,e,i)=>{i.d(e,{OpenloginAdapter:()=>g,getOpenloginDefaultOptions:()=>h});var n=i(13453),o=i(4942),r=i(32500),s=i(12169),a=i(57381),l=i.n(a);const h=()=>({adapterSettings:{network:n.dr.MAINNET,clientId:"",uxMode:n.$e.POPUP},loginSettings:{}});function c(t,e){var i=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),i.push.apply(i,n)}return i}function p(t){for(var e=1;e<arguments.length;e++){var i=null!=arguments[e]?arguments[e]:{};e%2?c(Object(i),!0).forEach((function(e){(0,o.Z)(t,e,i[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(i)):c(Object(i)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(i,e))}))}return t}class g extends r.J5{constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};super(t),(0,o.Z)(this,"name",r.rW.OPENLOGIN),(0,o.Z)(this,"adapterNamespace",r.yk.MULTICHAIN),(0,o.Z)(this,"type",r.hN.IN_APP),(0,o.Z)(this,"openloginInstance",null),(0,o.Z)(this,"status",r.MP.NOT_READY),(0,o.Z)(this,"currentChainNamespace",r.EN.EIP155),(0,o.Z)(this,"openloginOptions",void 0),(0,o.Z)(this,"loginSettings",{loginProvider:""}),(0,o.Z)(this,"privKeyProvider",null),this.setAdapterSettings(p(p({},t.adapterSettings),{},{chainConfig:t.chainConfig,clientId:t.clientId||"",sessionTime:t.sessionTime,web3AuthNetwork:t.web3AuthNetwork,useCoreKitKey:t.useCoreKitKey})),this.loginSettings=t.loginSettings||{loginProvider:""}}get chainConfigProxy(){return this.chainConfig?p({},this.chainConfig):null}get provider(){var t;return(null===(t=this.privKeyProvider)||void 0===t?void 0:t.provider)||null}set provider(t){throw new Error("Not implemented")}async init(t){if(super.checkInitializationRequirements(),!this.clientId)throw r.Ty.invalidParams("clientId is required before openlogin's initialization");if(!this.openloginOptions)throw r.Ty.invalidParams("openloginOptions is required before openlogin's initialization");let e=!1;if(this.openloginOptions.uxMode===n.$e.REDIRECT||this.openloginOptions.uxMode===n.$e.SESSIONLESS_REDIRECT){const t=(0,n.Gv)();Object.keys(t).length>0&&t._pid&&(e=!0)}this.openloginOptions=p(p({},this.openloginOptions),{},{replaceUrlOnRedirect:e}),this.openloginInstance=new n.ZP(p(p({},this.openloginOptions),{},{clientId:this.clientId,network:this.openloginOptions.network||this.web3AuthNetwork||n.dr.MAINNET})),r.cM.debug("initializing openlogin adapter init"),await this.openloginInstance.init(),this.status=r.MP.READY,this.emit(r.n2.READY,r.rW.OPENLOGIN);try{r.cM.debug("initializing openlogin adapter");this._getFinalPrivKey()&&(t.autoConnect||e)&&(this.rehydrated=!0,await this.connect())}catch(i){r.cM.error("Failed to connect with cached openlogin provider",i),this.emit("ERRORED",i)}}async connect(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{loginProvider:""};super.checkConnectionRequirements(),this.status=r.MP.CONNECTING,this.emit(r.n2.CONNECTING,p(p({},t),{},{adapter:r.rW.OPENLOGIN}));try{return await this.connectWithProvider(t),this.provider}catch(e){if(r.cM.error("Failed to connect with openlogin provider",e),this.status=r.MP.READY,this.emit(r.n2.ERRORED,e),null!==e&&void 0!==e&&e.message.includes("user closed popup"))throw r.RM.popupClosed();throw r.RM.connectionError("Failed to login with openlogin")}}async disconnect(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{cleanup:!1};if(this.status!==r.MP.CONNECTED)throw r.RM.notConnectedError("Not connected with wallet");if(!this.openloginInstance)throw r.Ty.notReady("openloginInstance is not ready");await this.openloginInstance.logout(),t.cleanup?(this.status=r.MP.NOT_READY,this.openloginInstance=null,this.privKeyProvider=null):this.status=r.MP.READY,this.rehydrated=!1,this.emit(r.n2.DISCONNECTED)}async authenticateUser(){if(this.status!==r.MP.CONNECTED)throw r.RM.notConnectedError("Not connected with wallet, Please login/connect first");return{idToken:(await this.getUserInfo()).idToken}}async getUserInfo(){if(this.status!==r.MP.CONNECTED)throw r.RM.notConnectedError("Not connected with wallet");if(!this.openloginInstance)throw r.Ty.notReady("openloginInstance is not ready");return await this.openloginInstance.getUserInfo()}setAdapterSettings(t){super.setAdapterSettings(t);const e=h();r.cM.info("setting adapter settings",t),this.openloginOptions=p(p(p({},e.adapterSettings),this.openloginOptions),t),t.web3AuthNetwork&&(this.openloginOptions.network=t.web3AuthNetwork),void 0!==t.useCoreKitKey&&(this.openloginOptions.useCoreKitKey=t.useCoreKitKey)}_getFinalPrivKey(){var t;if(!this.openloginInstance)return"";let e=this.openloginInstance.privKey;return null!==(t=this.openloginOptions)&&void 0!==t&&t.useCoreKitKey&&this.openloginInstance.coreKitKey&&(e=this.openloginInstance.coreKitKey),e}async connectWithProvider(){var t;let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{loginProvider:""};if(!this.chainConfig)throw r.Ty.invalidParams("chainConfig is required before initialization");if(!this.openloginInstance)throw r.Ty.notReady("openloginInstance is not ready");if(this.currentChainNamespace===r.EN.SOLANA){const{SolanaPrivateKeyProvider:t}=await Promise.all([i.e(201),i.e(945),i.e(833)]).then(i.bind(i,57945));this.privKeyProvider=new t({config:{chainConfig:this.chainConfig}})}else if(this.currentChainNamespace===r.EN.EIP155){const{EthereumPrivateKeyProvider:t}=await i.e(454).then(i.bind(i,58454));this.privKeyProvider=new t({config:{chainConfig:this.chainConfig}})}else{if(this.currentChainNamespace!==r.EN.OTHER)throw new Error("Invalid chainNamespace: ".concat(this.currentChainNamespace," found while connecting to wallet"));this.privKeyProvider=new s.FL}if(!this._getFinalPrivKey()||null!==(t=e.extraLoginOptions)&&void 0!==t&&t.id_token){var o;if(this.loginSettings.curve||(this.loginSettings.curve=this.currentChainNamespace===r.EN.SOLANA?n.x7.ED25519:n.x7.SECP256K1),!e.loginProvider&&!this.loginSettings.loginProvider)throw r.Ty.invalidParams("loginProvider is required for login");await this.openloginInstance.login(l()(this.loginSettings,e,{extraLoginOptions:p(p({},e.extraLoginOptions||{}),{},{login_hint:e.login_hint||(null===(o=e.extraLoginOptions)||void 0===o?void 0:o.login_hint)})}))}let a=this._getFinalPrivKey();if(a){if(this.currentChainNamespace===r.EN.SOLANA){const{getED25519Key:t}=await Promise.all([i.e(201),i.e(545)]).then(i.bind(i,26984));a=t(a).sk.toString("hex")}await this.privKeyProvider.setupProvider(a),this.status=r.MP.CONNECTED,this.emit(r.n2.CONNECTED,{adapter:r.rW.OPENLOGIN,reconnected:this.rehydrated})}}}}}]);
//# sourceMappingURL=835.f5ee5558.chunk.js.map